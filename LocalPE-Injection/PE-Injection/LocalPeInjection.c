/*
 * Explanation:
  - FetchPayloadDisk - Reads payload from disk.
 */

#include <windows.h>
#include <stdio.h>
#include <winternl.h>

// Function reads payload from disk

// Parameter: lstrFileName  -> String that hold the filename
// Parameter: ppBuffer      -> Pointer that will store the base address of the file that points to the payload
// Parameter: pdwFileSize   -> Pointer that will receive the file size in bytes
BOOL FetchPayloadDisk(_In_ LPCSTR lFilename, _Out_ PBYTE* ppBuffer, _Out_ PDWORD pdwFileSize) {
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE		pBuffer					= NULL;
    DWORD		dwFileSize				= 0x00,
            dwNumberOfBytesRead		= 0x00;
    // CreateFileA -> Opens our payload file that is located on disk.

    // Parameter: lpFilename                -> Hold the filename that need to be opend
    // Parameter: GENERIC_READ              -> The type of privilege of the file in question
    // Parameter: 0x00                      -> Prevents other process from opening the file
    // Parameter: NULL                      -> Prevent hFile handle can be used in child process
    // Parameter: OPEN_EXISTING             -> Only opens the file, when it's present on disk
    // Parameter: FILE_ATTRIBUTE_NORMAL     -> The payload file does not have other attributes set. This attribute is valid only if used alone
    // Parameter: NULL                      -> This parameter will be skipped if the file exists on disk
    hFile = CreateFileA(lFilename, GENERIC_READ, 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileA Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("[+] Successfully Read: \"%s\"\n", lFilename);

    // Determine filesize in bytes

    // Parameter: hFile                     -> Handle to file that will be opend
    // Parameter: NULL                      -> No need for high order double word
    if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        printf("[!] GetFileSize Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("[+] Successfully Read: \"%s\" -> Number of Bytes: %lu \n", lFilename, dwFileSize);

    // Allocate memory for reading the file

    // Function: GetProcessHeap()           -> Returns  heap of the current (calling) process
    // Parameter HEAP_ZERO_MEMORY           -> Allocated heap memory with 0's, (makes sure the allocated memory is empty and not filled with leftovers)
    if ((pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize)) == NULL) {
        printf("[!] HeapAlloc Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    // Reading file from disk

    // Parameter: pBuffer                   -> Handle to our payload file
    // Parameter: dwFileSize                -> Pointer to buffer that holds the filesize of our payload
    // Parameter: &dwNumberOfBytesRead      -> Specifies the maximum of the bytes that can be read
    // Parameter: NULL                      -> Since this operation is not sync'ed we can ignore this
    if (!ReadFile(hFile, pBuffer,dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        printf("[!] ReadFile Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("[+] Bytes Read: %lu from total number of bytes: %lu \n", dwNumberOfBytesRead, dwFileSize);

    // Cast Allocated Buffer to Output Buffer.
    *ppBuffer = pBuffer;

    // Set Filesize in Output Filesize.
    *pdwFileSize = dwFileSize;


    // Clean up.
    CloseHandle(hFile);
    if (!*ppBuffer) {
        HeapFree(GetProcessHeap(), 0x00, pBuffer);
    }
    return ((*ppBuffer != NULL) && (*pdwFileSize != 0x00)) ? TRUE : FALSE;
}

// Initialize PE Headers - Allows us to copy the data into PE_HDR struct. This struct hold data dirs required for lading the PE
typedef struct _PE_HDRS
{
    PBYTE					pFileBuffer;
    DWORD					dwFileSize;

    PIMAGE_NT_HEADERS		pImgNtHdrs;
    PIMAGE_SECTION_HEADER	pImgSecHdr;

    PIMAGE_DATA_DIRECTORY	pEntryImportDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryBaseRelocDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryTLSDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryExceptionDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryExportDataDir;

    BOOL					bIsDLLFile;
}PE_HDRS, *PPE_HDRS;


// Function that will populate elements of PE HDRS Structure

// Parameter: pPeHdrs                       -> Point to PE_HDRS structure
// Parameter: pFileBuffer                   -> Hold base address of the file that will be read
// Parameter: dwFileSize                    -> Holds file size (bytes) of the read file
BOOL InitPEStruct(_Out_ PPE_HDRS pPeHdrs, _In_ PBYTE pFileBuffer, _In_ DWORD dwFilSize) {

    // Check if parameters hold value
    if (!pPeHdrs || !pFileBuffer || !dwFilSize)
        return FALSE;

    // Fill structure with data
    pPeHdrs->pFileBuffer = pFileBuffer;
    pPeHdrs->dwFileSize = dwFilSize;
    pPeHdrs->pImgNtHdrs = (PIMAGE_NT_HEADERS)(pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);

    // Verify that pPeHdrs has correctly initialized NT Header
    if (pPeHdrs->pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // Initialize other members of Pe_HDRS struct
    pPeHdrs->bIsDLLFile = (pPeHdrs->pImgNtHdrs->FileHeader.Characteristics & IMAGE_FILE_DLL) ? TRUE : FALSE;
    pPeHdrs->pImgSecHdr = IMAGE_FIRST_SECTION(pPeHdrs->pImgNtHdrs);
    pPeHdrs->pEntryImportDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    pPeHdrs->pEntryBaseRelocDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    pPeHdrs->pEntryTLSDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
    pPeHdrs->pEntryExceptionDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
    pPeHdrs->pEntryExportDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

    printf("[+] Successfully Initialized pPeHdrs!\n");

    return TRUE;
}

/*
 * IAT Reimplementation:
 *  - When the system loader handles a PE image, its duty includes resolved IAT table by loading the required DLLs into the process.
 *  - Since we load our own PE loader, it's required to pass the IAT addresses manually.
 */

// Parameter: pEntryImportDataDir           -> Pointer that holds data dir of PE file
// Parameter: pPeBaseAddress            -> Base address of PE payload
BOOL FixImportAddressTable(_In_ PIMAGE_DATA_DIRECTORY pEntryImportDataDir, _In_ PBYTE pPeBaseAddress) {

    // Pointer to an import descriptor for a DLL
    PIMAGE_IMPORT_DESCRIPTOR	pImgDescriptor		= NULL;
    // Iterate over the import descriptors
    for (SIZE_T i = 0; i < pEntryImportDataDir->Size; i += sizeof(IMAGE_IMPORT_DESCRIPTOR)) {
        // Get the current import descriptor
        pImgDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(pPeBaseAddress + pEntryImportDataDir->VirtualAddress + i);
        // If both thunks are NULL, we've reached the end of the import descriptors list
        if (pImgDescriptor->OriginalFirstThunk == 0 && pImgDescriptor->FirstThunk == 0)
            break;

        // Retrieve information from the current import descriptor
        LPSTR		cDllName					= (LPSTR)(pPeBaseAddress + pImgDescriptor->Name);
        ULONG_PTR	uOriginalFirstThunkRVA		= pImgDescriptor->OriginalFirstThunk;
        ULONG_PTR	uFirstThunkRVA				= pImgDescriptor->FirstThunk;
        SIZE_T		ImgThunkSize				= 0x00;	// Used to move to the next function (iterating through the IAT and INT)
        HMODULE		hModule						= NULL;


        // Try to load the DLL referenced by the current import descriptor
        if (!(hModule = LoadLibraryA(cDllName))) {
           printf("[!] LoadLibraryA Failed With Error Code: %lu \n", GetLastError());
            return FALSE;
        }

        // Iterate over the imported functions for the current DLL
        while (TRUE) {

            // Get pointers to the first thunk and original first thunk data
            PIMAGE_THUNK_DATA			pOriginalFirstThunk			= (PIMAGE_THUNK_DATA)(pPeBaseAddress + uOriginalFirstThunkRVA + ImgThunkSize);
            PIMAGE_THUNK_DATA			pFirstThunk					= (PIMAGE_THUNK_DATA)(pPeBaseAddress + uFirstThunkRVA + ImgThunkSize);
            PIMAGE_IMPORT_BY_NAME		pImgImportByName			= NULL;
            ULONG_PTR					pFuncAddress				= NULL;

            // At this point both 'pOriginalFirstThunk' & 'pFirstThunk' will have the same values
            // However, to populate the IAT (pFirstThunk), one should use the INT (pOriginalFirstThunk) to retrieve the
            // functions addresses and patch the IAT (pFirstThunk->u1.Function) with the calculated address.
            if (pOriginalFirstThunk->u1.Function == 0 && pFirstThunk->u1.Function == 0) {
                break;
            }

            // If the ordinal flag is set, import the function by its ordinal number
            if (IMAGE_SNAP_BY_ORDINAL(pOriginalFirstThunk->u1.Ordinal)) {
                char szOrdinal[20];  // Adjust the size based on the maximum length you expect
                sprintf(szOrdinal, "%lu", (unsigned long)pOriginalFirstThunk->u1.Ordinal);

                if (!(pFuncAddress = (ULONG_PTR)GetProcAddress(hModule, szOrdinal))) {
                    printf("[!] Could Not Import !%s#%s \n", cDllName, szOrdinal);
                    return FALSE;
                }
            }

            // Import function by name
            else {
                pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pPeBaseAddress + pOriginalFirstThunk->u1.AddressOfData);
                if ( !(pFuncAddress = (ULONG_PTR)GetProcAddress(hModule, pImgImportByName->Name)) ) {
                    printf("[!] Could Not Import !%s.%s \n", cDllName, pImgImportByName->Name);
                    return FALSE;
                }
            }

            // Install the function address in the IAT
            pFirstThunk->u1.Function = (ULONGLONG)pFuncAddress;

            // Move to the next function in the IAT/INT array
            ImgThunkSize += sizeof(IMAGE_THUNK_DATA);
        }
    }

    return TRUE;
}