/*
Explanation:
    - The following script is going to show different information types inside a PE header of an executable.

RVA:
    - Relative Virtual Address
    - RVAs are addresses that are used to reference locations within a PE file

DOS Header:
    - DOS Header is located at the beginning of a PE file and contains information about the file, such as size, RVA to the NT header
*/

#include <Windows.h>
#include <stdio.h>

BOOL ReadPeFile(LPCSTR lpFileName, PBYTE* pPe, SIZE_T* sPe) {
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE pBuff = NULL;
    DWORD dwNumberOfBytesRead = 0;
    DWORD dwFileSize = 0;

    printf("[+] Reading %s\n", lpFileName);

    // Opens the specified user file
    hFile = CreateFileA(lpFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileA Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE) {
        printf("[!] GetFileSize Failed With Error Code: %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    // Allocate memory in the heap
    pBuff = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize);
    if (pBuff == NULL) {
        printf("[!] HeapAlloc Failed With Error : %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    if (!ReadFile(hFile, pBuff, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        printf("[!] ReadFile Failed With Error Code: %d\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, pBuff); // Free allocated memory
        CloseHandle(hFile);
        return FALSE;
    }
    CloseHandle(hFile);

    printf("[+] Successfully Opened File!\n");

    // Assign the output to the appropriate parameters
    *pPe = pBuff;
    *sPe = dwFileSize;

    return TRUE;
}

/*
typedef struct _IMAGE_DOS_HEADER
{
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
*/

VOID PeParse(PBYTE pPe) {
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pPe;

    // 0x5a4d == MZ (magic bytes of MZ)
    if (pImgDosHdr->e_magic != 0x5A4D) {
        return;
    }

    /*
    typedef struct _IMAGE_NT_HEADERS {
      DWORD                   Signature;
      IMAGE_FILE_HEADER       FileHeader;
      IMAGE_OPTIONAL_HEADER32 OptionalHeader;
    } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
    */

    // RVA to NT Headers structure
    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pPe + pImgDosHdr->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        return;
    }

    printf("\n---------------------[ File Headers ]---------------------\n");
    /*
    typedef struct _IMAGE_FILE_HEADER {
      WORD  Machine;
      WORD  NumberOfSections;
      DWORD TimeDateStamp;
      DWORD PointerToSymbolTable;
      DWORD NumberOfSymbols;
      WORD  SizeOfOptionalHeader;
      WORD  Characteristics;
    } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
    */

    // Accessing file header by accessing IMAGE_NT_HEADER structure
    IMAGE_FILE_HEADER ImgFileHdr = pImgNtHdrs->FileHeader;

    // Characteristics member represents attributes of PE file such as; DLL, EXE
    // Checks whether it is an executable image
    if (ImgFileHdr.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
        printf("[+] Executable File Is An: ");

        if (ImgFileHdr.Characteristics & IMAGE_FILE_DLL)
            printf("DLL\n");
        else if (ImgFileHdr.Characteristics & IMAGE_SUBSYSTEM_NATIVE)
            printf("SYS\n");
        else if (ImgFileHdr.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)
            printf("EXE\n");
        else
            printf("[!] Could Not Determine Type of File\n");
    }

    printf("[+] File Architecture: %s\n", ImgFileHdr.Machine == IMAGE_FILE_MACHINE_I386 ? "x32" : "x64");
    printf("[+] Number of Sections Inside PE: %u\n", ImgFileHdr.NumberOfSections);
    printf("[+] Size Of The Optional Header: %u\n", ImgFileHdr.SizeOfOptionalHeader);
    printf("[+] Characteristics Of PE: %04X\n", ImgFileHdr.Characteristics);
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("[!] Please Enter PE File To Parse ...\n");
        return -1;
    }

    PBYTE pPe = NULL;
    SIZE_T sPe = 0;

    if (!ReadPeFile(argv[1], &pPe, &sPe)) {
        return -1;
    }

    printf("[+] \"%s\" Read At: 0x%p Of Size: %zu\n", argv[1], pPe, sPe);

    PeParse(pPe);

    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    HeapFree(GetProcessHeap(), NULL, pPe);

    return 0;
}
